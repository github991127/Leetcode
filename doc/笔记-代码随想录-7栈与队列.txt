⚫●◯○◦◉◍◑◙◎◌
⚫栈与队列理论基础
●【C++】
栈和队列是STL的两个数据结构。STL(Standard Template Library)标准模板库
HP STL第一个实现版本，开源
P.J.Plauger被Visual C++编译器所采用，不开源
SGI STL被Linux的C++编译器GCC所采用，开源，可读性高
●SGI STL
栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则。
栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。
底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。栈往往不被归类为容器，而被归类为container adapter（容器适配器）
栈的底层实现可以是deque（默认），vector，list

⚫232. 用栈实现队列
复用，即抽象成一个好用的函数或者工具类多次调用。一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题。

⚫225. 用队列实现栈
能使用同一处空间，就不要复制到另一处

⚫20. 有效的括号
匹配问题都是栈的强项
先分析true和false的各种情况，确保面面俱到

⚫1047. 删除字符串中的所有相邻重复项
递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数
在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）

⚫150. 逆波兰表达式求值
将中缀表达式，转化为后缀表达式之后：["4", "13", "5", "/", "+"] 
计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， 所以后缀表达式对计算机来说是非常友好的。

⚫239. 滑动窗口最大值
单调队列，将队列前面大于的数全部挤掉
if self.queue and value == self.queue[0]: # 窗口缩小，弹出队首的相等值，就是窗口左的值
这里可能会担心如果这个值只是恰好相等但不是窗口左怎么办？
情况1：这个值早就被后面的更大值挤掉了，那么不符合条件不用弹出
情况2：这个值已经最大，位于队首。由于是单调队列，队首后面的值都小于等于队首，只有窗口左移这一条件才能弹出

⚫347. 前 K 个高频元素
●堆是一棵完全二叉树，树中每个父结点的值都大于等于其左右孩子的值，为大顶堆（相反小于等于为小顶堆）
大顶堆弹出的都是大元素，因此适合保留小元素的问题
【Python】
﻿●Python的内置标准库heapq实现的是小顶堆
import heapq
heapq.heappush(pri_que, (value, key)) # 堆名,元素
heapq.heappop(pri_que) # 堆名
●要想利用heapq实现大顶堆有两种思路：
◾将数据取反进行push（此方法只针对数值型数据）
◾重载__lt__函数（针对自定义数据类型使用）

⚫●◯○◦◉◍◑◙◎◌
⚫动态规划理论基础
确定dp数组（dp table）以及下标的含义
确定递推公式
dp数组如何初始化
确定遍历顺序
举例推导dp数组
⚫509. 斐波那契数
dp：第i个数为dp[i]
公式：dp[i]=dp[i-2]+dp[i-1]
初始化：dp[0]=0，dp[1]=1
遍历顺序：顺序
⚫70. 爬楼梯
同上
dp：第i步的步数为dp[i]
公式：第i步的步数只看最后一步，可以有1或2，那么就是将减去最后一步的所有可能加起来，dp[i]=dp[i-2]+dp[i-1]
初始化：dp[1]=1，dp[2]=2
遍历顺序：顺序
⚫746. 使用最小花费爬楼梯
dp：爬到i楼的体力为dp[i]，顶楼是i+1
公式：dp[i]=min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
初始化：dp[0]=0，dp[1]=0
遍历顺序：顺序
⚫62. 不同路径
dp：第ij格的策略数为dp[i][j]
公式：dp[i][j]=dp[i-1][j]+dp[i][j-1]
初始化：dp[i][*]=1，dp[*][j]=1
遍历顺序：二维顺序
⚫63. 不同路径 II
同上
⚫343. 整数拆分
dp：n的拆分积为dp[n]
公式：dp[i] = max(dp[i], dp[i - j] * dp[j])
初始化：dp[2]=1，dp[3]=2，但是计算时dp[n]=n（n<4），因为小数值123拆分积小于他本身，所以用本身参与计算
遍历顺序：顺序
⚫96. 不同的二叉搜索树
找规律，通过dp[1] 和 dp[2] 来推导出来dp[3]，如果看不出来再画出dp[4]，看的是左右两个子树的个数结果的乘积：03，12，21，30
dp：第i个数的排列树为dp[i]
公式：dp[i] += dp[j] * dp[i - j - 1]
初始化：dp[0]=1，dp[1]=1
遍历顺序：顺序，每层j从0到i-1
⚫01背包理论基础（一）
dp：装前i个物品，容量为j的背包，最大价值为dp[i][j]
公式：dp[i][j] = max(dp[i - 1][j], value[i] + dp[i - 1][j - weight[i]])
初始化：dp[0][j] = value[0]
遍历顺序：顺序，内层容量或内层物品
⚫01背包理论基础（二）
dp：装前i个物品，容量为j的背包，最大价值为dp[j]
公式：dp[j] = max(dp[j],value[i] + dp[j - weight[i]])
初始化：dp[j] = value[0]
遍历顺序：逆序，内层容量
●一维数组能顺序遍历吗？
不能。二维数组从上次循环的[i - 1]选取子状态，压缩后的一维数组从本次循环的左侧[i]选取，而本次循环的左侧[i]可能会更新。因此需要逆序使得左侧后更新
换句话说，更新需要左n列，上一行的数据不变，从右到左可以让左n列后更新
eg：物品重量价值均为1，2，装入4的背包，得出结果为4（正确为3）
●一维数组能内层物品遍历吗？
不能。如果背包容量一定是要倒序遍历，还放在上一层，那么每个dp[j]就只会放入一个物品
⚫416. 分割等和子集
同01背包，容量为偶数总和的一半
⚫1049.最后一块石头的重量II
同01背包，最大容量为总和的一半（向下取整），求最终结果两份容量的差
⚫494. 目标和
A+B,A-B，装满容量为A的01背包，组合问题
dp：装满容量为j的组合有dp[j]种
公式：dp[j] += dp[j - nums[i]]
初始化：dp[0]=1，dp[*]=0，dp[nums[0]]=1
遍历顺序：同01背包，装当前物品时，如果物品已经大于容量，那组合数肯定不会增加，所以到num就不用往回退了（回退反而导致负数容量计算错误）
⚫474. 一和零
dp：装前x个物品的最大物品数为dp[i][j]
公式：dp[i][j] = max(dp[i][j], 1 + dp[i - one][j - zero])
初始化：dp[i][j] = 0
遍历顺序：同01背包，装当前物品时，如果物品已经大于容量，那物品数肯定不会增加，所以到num就不用往回退了（回退反而导致负数容量计算错误）
⚫完全背包理论基础
01背包和完全背包唯一不同就是体现在遍历顺序上
●一维数组能顺序遍历吗？
可以。二维数组从上次循环的[i - 1]选取子状态，压缩后的一维数组从本次循环的左侧[i]选取，而本次循环的左侧[i]可能会更新。完全背包需要这样的更新，这保证了一个物品能放入多次
eg：物品重量价值均为1，2，装入4的背包，得出结果为4（正确为4）
●一维数组能内层物品遍历吗？
可以。如果背包容量不一定是要倒序遍历，那for循环的内外并不影响放入物品
⚫518.零钱兑换II
dp：装前i个物品，容量为j的背包，组合数为dp[j]
公式：dp[j] += dp[j - value]
初始化：dp[0] = 1
遍历顺序：顺序，内层容量
●一维数组能内层物品遍历吗？
不能。组合数没有顺序，先遍历物品会导致，每次容量状态所使用的前状态，都是考虑了所有物品的更新后的数组，这样计算顺序就包含了{1, 2} 和 {2, 1}两种情况。相反如果是内层容量遍历，每次容量状态所使用的前状态，只是考虑了当前物品的更新后的数组，这样物品顺序就是先来先到{1, 2}
eg：物品重量价值均为1，2，3，装入3的背包，得出结果为4（正确为3）
⚫377. 组合总和 Ⅳ
同上，换为排列数，内层物品遍历
⚫70. 爬楼梯
同上，换为排列数，物品为1，2，……n
⚫322. 零钱兑换
dp：装前i个物品，容量为j的背包，最小物品数为dp[j]
公式：dp[j] = min(dp[j], 1 + dp[j - i])
初始化：dp[*] = float('inf')，dp[0] = 0
遍历顺序：顺序
⚫139. 单词拆分
dp：装前i个物品（字典单词），容量为j的背包（总单词），满足状态为dp[j]
公式：dp[j] = dp[j] or (dp[j - len(i)] and i == s[j - len(i):j])
初始化：dp[0] = True
遍历顺序：排列数，内层物品遍历
●一维数组能内层容量遍历吗？
不能。先遍历背包会导致，物品只有先来后到的一种顺序（即不考虑顺序的组合）
eg：s = "applepenapple", wordDict = ["apple", "pen"] 
"apple", "pen" 是物品，要求物品的组合一定是 "apple" + "pen" + "apple"，而不是"apple" + "apple" + "pen"。强调顺序，因此是计算排列
⚫动态规划：关于多重背包，你该了解这些！
多种物品的01背包，遍历前将数组扩充为每件物品各一个







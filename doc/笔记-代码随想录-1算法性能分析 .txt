⚫●◯○◦◉◍◑◙◎◌
█⬛◼■◾⬜◻□◽◘◪◫
★◆◇◈◛◬◮◢↑↓←→✓
⚫关于时间复杂度，你不知道的都在这里！
●什么是大O
大O用来表示上界的
业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界
eg：严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)。但是我们依然说快速排序是O(nlogn)的时间复杂度

●不同数据规模的差异
算法的时间复杂度在不同数据输入规模下有差异，一般情况为数据规模很大，忽略常数项
如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）
如果数据规模很大，O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(nlogn)线性对数阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶
eg：因为对数的底数可以提取到前面作为常数，所以统一说 logn，也就是忽略底数（常数项）的描述

●举一个例子
通过这道面试题目，来分析一下时间复杂度。题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。

如果是暴力枚举的话，时间复杂度是多少呢，是O(n^2)么？
这里一些同学会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。

接下来再想一下其他解题思路。
先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。
那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。最后很明显O(m × n × logn) 要优于O(m × n × n)！

当然这不是这道题目的最优解，我仅仅是用这道题目来讲解一下时间复杂度

⚫On的算法居然超时了，此时的n究竟是多大？
●超时是怎么回事
程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s
如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法

●从硬件配置看计算机的性能
2015年MacPro为例，CPU配置：2.7 GHz Dual-Core Intel Core i5 
2.7 GHz 奔腾双核，i5处理器

1GHz（兆赫）= 1000MHz（兆赫）
1MHz（兆赫）= 1百万赫兹
1GHz = 10亿Hz，表示CPU可以一秒脉冲10亿次（有10亿个时钟周期）

eg：1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。
而且计算机的cpu也不会只运行我们自己写的程序上，同时cpu也要执行计算机的各种进程任务等等，我们的程序仅仅是其中的一个进程而已。

1s处理的数据规模大致范围
O(n)线性阶=10^8
O(nlogn)线性对数阶=10^7
O(n^2)平方阶=10^4

⚫通过一道面试题目，讲一讲递归算法的时间复杂度！
递归算法的时间复杂度 = 递归次数 * 每次递归的操作数
进行了多少次递归的话，就是看这棵树上有多少个节点。

⚫递归算法的时间与空间复杂度分析！
递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度
进行了多少次递归的话，就是看这棵树的层深。
因为每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度

eg：递归二分查找的空间复杂度
在C/C++中函数传递数组参数，不是整个数组拷贝一份传入函数而是传入的数组首元素地址。
也就是说每一层递归都是公用一块数组地址空间的，所以 每次递归的空间复杂度是常数即：O(1)。递归深度是logn
1 * logn = O(logn)
⚫刷了这么多题，你了解自己代码的内存消耗么？
●C++的内存管理

栈区间的数据在代码块执行结束之后，系统会自动回收，而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地
1栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
2堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回

代码区和数据区所占空间都是固定的，而且占用的空间非常小
3未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量
4初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量
5程序代码区(Text)：存放函数体的二进制代码

Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情

●如何计算程序占用多大内存★
char,short-int,long-float,double,pointer
32位:12-44-484字节（byte）
64位:12-48-488
64位long,pointer扩大两倍
现在使用的计算机一般都是64位了，所以编译器也都是64位的。64位编译器使用8个字节的指针才能寻找所有的内存地址

●内存对齐
原因1速度：
CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件
内存对齐，牺牲内存资源，换取读取时间（运行速度）

原因2平台：
不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
内存对齐，使得同一个程序可以在多平台运行

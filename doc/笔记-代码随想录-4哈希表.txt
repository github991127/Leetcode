⚫●◯○◦◉◍◑◙◎◌
⚫哈希表理论基础
●哈希函数
一般哈希碰撞有两种解决方法：拉链法和线性探测法。
拉链法：右移，查找时通过索引
线性探测法：下移，查找时顺序向下，需要哈希表长大于数据表长
●常见的三种哈希结构
【C++】
集合	底层实现	是否有序	数值是否可以重复	能否更改数值	查询效率	增删效率
std::set	红黑树	有序	否	否	O(log n)	O(log n)
std::multiset	红黑树	有序	是	否	O(logn)	O(logn)
std::unordered_set	哈希表	无序	否	否	O(1)	O(1)

std::set不可重复的模拟有序哈希
std::multiset可重复的模拟有序哈希
std::unordered_set真无序哈希
均不可修改
●总结
方便快速查找，牺牲空间换时间
⚫242. 有效的字母异位词
ord(c) # 返回十进制整数ASCll数值
查找内容个数有限，建立数组计数模拟哈希
⚫349. 两个数组的交集
【C++】
使用数组：数据范围受限，小而快
使用map：数据范围不受限，占用空间更大，速度更慢，set把数值映射到key上都要做hash计算的
因此判断有限内容采用数组。如英文字母，小范围整数
⚫202. 快乐数
【python】
判断是否无限循环，使用set()集合，无序不重复，不能index查找
获取数值各个位上的数，使用n_str = str(n)，再循环转换为int
⚫1. 两数之和
【C++】
映射	底层实现	是否有序	数值是否可以重复	能否更改数值	查询效率	增删效率
std::map	红黑树	key有序	key不可重复	key不可修改	O(log n)	O(log n)
std::multimap	红黑树	key有序	key可重复	key不可修改	O(log n)	O(log n)
std::unordered_map	哈希表	key无序	key不可重复	key不可修改	O(1)	O(1)
（特性同上set）
std::map不可重复的模拟有序哈希
std::multimap可重复的模拟有序哈希
std::unordered_map真无序哈希
均不可修改
⚫454. 四数相加II
偶数层循环，考虑对半拆开，前半统计，后半判断，可以降低时间复杂度
⚫383. 赎金信
使用数组
⚫15. 三数之和
三个元素也可以用双指针，将第一个元素作为变量用于判断条件即可
关键是去重，三个元素都可能重复需要去重
⚫18. 四数之和
同上

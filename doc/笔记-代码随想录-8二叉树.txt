⚫●◽★
——————————————————————
⚫二叉树理论基础
●类型
◽满二叉树
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。（填满每一层）
◽完全二叉树
除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。（填满每一层除了最后一层，最后一层从左到右填）
◽二叉搜索树，二叉排序树，BRT树（Binary Search Tree）
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉搜索树
◽平衡二叉搜索树，AVL树（Adelson-Velsky and Landis）
它是二叉搜索树
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
它的左、右子树也分别为平衡二叉搜索树
C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn
◽红黑树，RBT树（Red Black Tree）

●存储
数组存储：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2
链表存储：指针指向孩子节点，用链式表示的二叉树更有利于我们理解，所以一般我们都是用链式存储二叉树

●遍历
分为广度优先和深度优先，深度优先遍历中：有三个顺序，前中后序遍历。这里前中后，其实指的就是中间节点的遍历顺序
广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的
前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的

⚫144. 二叉树的前序遍历
递归三要素
●确定递归函数的参数和返回值【第一次的自变量和最后一次的返回类型】
确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
●确定终止条件【最后一次递归】
写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
●确定单层递归的逻辑【第一次递归】
确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

⚫102. 二叉树的层序遍历
通过队列中当前的元素个数决定弹出次数和层高

⚫226. 翻转二叉树
这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了
那么层序遍历可以不可以呢？依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！
